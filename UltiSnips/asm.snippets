snippet scode "Start basic code for assembly" b
.data


.text


.global main


main:


endsnippet

snippet scodes "Start basic code for assembly with _start label" b
.data


.text


.globl _start


_start:


endsnippet

snippet lo "Long" b
$1: .long $2
endsnippet

snippet wo "Word" b
$1: .word $2
endsnippet

snippet by "Byte" b
$1: .byte $2
endsnippet

snippet sp "Space" b
$1: .space $2
endsnippet

snippet ai "Ascii" b
$1: .ascii "$2"
endsnippet

snippet az "Asciz" b
$1: .asciz "$2"
endsnippet

snippet ze "Zero" b
$1: .zero "$2"
endsnippet

snippet qu "Quad" b
$1: .quad "$2"
endsnippet

snippet si "Single" b
$1: .single "$2"
endsnippet

snippet do "Double" b
$1: .single "$2"
endsnippet
snippet fl "Float" b
$1: .single "$2"
endsnippet

snippet oc "Octa" b
$1: .single "$2"
endsnippet

snippet sh "Short" b
$1: .single "$2"
endsnippet

snippet exit0 "Exit without error" b
# Exit without error
movl \$1, %eax
xorl %ebx, %ebx
int \$0x80

endsnippet

snippet exit "Exit with error" b
# Exit with error
mov \$1, %eax
mov $1, %ebx # Error code
int \$0x80

endsnippet

snippet readfstdin "Read fixed length text from stdin" b
# Read fixed length text
mov \$3, %eax
mov \$2, %ebx # stdin
mov $1, %ecx # String
mov $2, %edx # Lenght
int \$0x80

endsnippet
snippet writestdout "Write text to stdout" b
# Write text
mov \$4, %eax
mov \$1, %ebx # stdout
mov $1, %ecx # String
mov $2, %edx # Lenght
int \$0x80

endsnippet

snippet writestderr "Write text to stderr" b
# Write text
mov \$4, %eax
mov \$2, %ebx # stderr
mov $1, %ecx # String
mov $2, %edx # Lenght
int \$0x80

endsnippet

snippet * "Multiplication" b
# Multiply two number - %eax = %eax * op
mov $1, %eax
mul $2

endsnippet

snippet / "Division" b
# Divide two numbers - %eax(quotinet) + %edx(remainder) = %eax / op
mov $1, %eax
div $2

endsnippet

snippet jmpl "Conditional lower jump" b
cmp $1, $2
jl $3 # Jump if op2 < op1

endsnippet

snippet jmple "Conditional lower or equal jump" b
cmp $1, $2
jle $3 # Jump if op2 <= op1

endsnippet

snippet jmpe "Conditional equal jump" b
cmp $1, $2
je $3 # Jump if op2 == op1

endsnippet

snippet jmpn "Conditional not equal jump" b
cmp $1, $2
jn $3 # Jump if op2 != op1

endsnippet

snippet jmpg "Conditional greater jump" b
cmp $1, $2
jg $3 # Jump if op2 > op1

endsnippet

snippet jmpge "Conditional greater or equal jump" b
cmp $1, $2
je $3 # Jump if op2 >= op1

endsnippet

snippet loopn "Loop n times" b
# Loop for op1 times
mov $1, %ecx

et_for:
	# Instructions
	$2

	# Loop
	loop et_for

endsnippet

snippet loopnn "Loop n-1 times" b
# Loop for op1 - 1 times
mov $1, %ecx
dec %ecx

et_for:
	# Instructions
	$2

	# Loop
	loop et_for

endsnippet

snippet loopv "Loop through a vector" b
# Loop through a vector
lea $1, %edi
xor %ecx, %ecx

et_for:
	# Loop until op2
	cmp %ecx, $2
	je $3

	# Instructions
	$4

	inc %ecx
	jmp et_for

endsnippet

snippet mul "Multiply" b
xor %edx, %edx
mov $1, %eax
mul $2
endsnippet

snippet mul64 "Multiply numbers greater than 2^32" b
mov $1, %edx
mov $2, %eax
mul $3
endsnippet

snippet div "Divide" b
xor %edx, %edx
mov $1, %eax
div $2
endsnippet

snippet div64 "Divide numbers greater than 2^32" b
mov $1, %edx
mov $2, %eax
div $3
endsnippet

snippet pr "Call printf" b
pushl $1
call printf
popl $2
endsnippet

snippet sc "Call scanf" b
pushl $1
call scanf
popl $2
endsnippet

snippet mindex "Current index from a matrix" b
# Current index from a matrix stored in %eax
xor %edx, %edx
movl $1, %eax # line index
mull $2 # number of columns
addl $3, %eax # column index
endsnippet

snippet ffl "Call fflush" b
pushl \$0
call fflush
popl $1
endsnippet

snippet at "Call atoi" b
pushl $1
call atoi
popl $2
endsnippet

snippet len "Call strlen" b
pushl $1
call strlen
popl $2
endsnippet

snippet proc "Basic procedure" b
$1:
pushl %ebp
movl %esp, %ebp

$2

popl %ebp
ret
endsnippet
