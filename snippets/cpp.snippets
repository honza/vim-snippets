# darkprof <dark_prof@mail.ru>

# include
extends c

# header include guard
snippet once
	#pragma once
# #ifndef ${1:`toupper(vim_snippets#Filename('$1_HPP', 'UNTITLED_HPP'))`}
# #define $1

# ${0}

# #endif /* end of include guard: $1 */

snippet tdu "using type = other"
	using ${1:newtype} = ${2:lasttype};
	${0}

##
## Preprocessor
# #include <...>
snippet inc "hpp include"
	#include <${1:global}.hpp>

snippet incc
	#include <${1:iostream}>

snippet binc
	#include <boost/${1:shared_ptr}.hpp>

##
## STL Collections
# std::string
snippet string "std::string"
	std::string ${1:name}${2};
	${0}

# std::array
snippet array
	std::array<${1:T}, ${2:N}> ${3};

# std::vector
snippet vector
	std::vector<${1:T}> ${2};

# std::deque
snippet deque
	std::deque<${1:T}> ${2};

# std::forward_list
snippet flist
	std::forward_list<${1:T}> ${2};

# std::list
snippet list
	std::list<${1:T}> ${2};

# std::set
snippet set
	std::set<${1:T}> ${2};

# std::map
snippet map
	std::map<${1:Key}, ${2:T}> ${3};

# std::multiset
snippet mset
	std::multiset<${1:T}> ${2};

# std::multimap
snippet mmap
	std::multimap<${1:Key}, ${2:T}> ${3};

# std::unordered_set
snippet uset
	std::unordered_set<${1:T}> ${2};

# std::unordered_map
snippet umap
	std::unordered_map<${1:Key}, ${2:T}> ${3};

# std::unordered_multiset
snippet umset
	std::unordered_multiset<${1:T}> ${2};

# std::unordered_multimap
snippet ummap
	std::unordered_multimap<${1:Key}, ${2:T}> ${3};

# std::stack
snippet stack
	std::stack<${1:T}> ${2};

# std::queue
snippet queue
	std::queue<${1:T}> ${2};

# std::priority_queue
snippet pqueue
	std::priority_queue<${1:T}> ${2};

##
## Access Modifiers
# private
snippet pri
	private

# protected
snippet pro
	protected

# public
snippet pub
	public

# friend
snippet fr
	friend

# mutable
snippet mu
	mutable

# enum class
snippet cenum "class enum"
	enum class ${1:name} : ${2:uint}
	{
		${3}
	};

	${0}

##
## Class
# class
snippet cl
	class ${1:`vim_snippets#Filename('$1', 'name')`}
	{
	public:
		$1 ( ${2} );
		virtual ~$1 ();

	protected:
		${3};
	};

##
## Class
# class
snippet dcl
	/** @class $1
	 *  @brief ${3:Brief class description}
	 *
	 *  ${4:Detailed description}
	**/
	class ${1:`vim_snippets#Filename('$1', 'name')`}
	{
	public:
	  /**
	   * @brief Create $1
	  **/
		$1(${2});
	  
	  /**
	   * @brief Destroy $1
	  **/
		virtual ~$1();

	protected:
		${5}; /**< ${6:Member description} **/
	};

##
## Class with copy, move constructors, operators
# class
snippet cle
	class ${1:`vim_snippets#Filename('$1', 'name')`}
	{
	public:
	  $1 ( ${2} );
	  $1 ( const $1& copy );
	  $1& operator=( const $1& copy );
	  $1 ( $1&& move );
	  $1& operator=( $1&& move );
		virtual ~$1();

	protected:
		${3};
	};

##
## Class with copy, move constructors, operators
# class
snippet dcle
	/** @class $1
	 *  @brief ${3:Brief class description}
	 *
	 *  ${4:Detailed description}
	**/
	class ${1:`vim_snippets#Filename('$1', 'name')`}
	{
	public:
	  /**
	   * @brief Create $1
	  **/
	  $1 ( ${2} );
	  
	  /**
	   * @brief Copy $1 object.
	  **/
	  $1 ( const $1& copy );
	  
	  /**
	   * @brief Copy operator for $1 object.
	  **/
	  $1& operator=( const $1& copy );
	  
	  /**
	   * @brief Move $1 object.
	  **/
	  $1 ( $1&& move );
	  
	  /**
	   * @brief Move operator for $1 object.
	  **/
	  $1& operator=( $1&& move );
	  
	  /**
	   * @brief Destroy $1
	  **/
		virtual ~$1();

	protected:
		${5}; /**< ${6:Member description} **/
	};

snippet tmconcp1 "copy constructor"
	template <class ${2:T}>
	${1:`vim_snippets#Filename('$1', 'ClassName')`}<$2>::$1 ( const $1<$2>& ${3:copy} ) 
	{
		if ( this != &$3 ) {
			${0:${VISUAL}}
		}
	}

snippet tmopcp "copy operator"
	template <class ${2:T}>
	$1<$2>&
	${1:`vim_snippets#Filename('$1', 'ClassName')`}<$2>::operator= ( const $1<$2>& ${3:copy} ) 
	{
		if ( this != &$3 ) {
			${0:${VISUAL}}
		}

		return *this;
	}

snippet tmconmv "move constructor"
	template <class ${2:T}>
	${1:`vim_snippets#Filename('$1', 'ClassName')`}<$2>::$1 ( $1<$2>&& ${3:move} ) 
	{
		if ( this != &$3 ) {
			${0:${VISUAL}}
		}
	}

snippet tmopmv "move operator"
	template <class ${2:T}>
	$1<$2>&
	${1:`vim_snippets#Filename('$1', 'ClassName')`}<$2>::operator= ( $1<$2>&& ${3:move} ) 
	{
		if ( this != &$3 ) {
			${0:${VISUAL}}
		}

		return *this;
	}

snippet tmdes "template destructor"
	template <class ${2:T}>
	${1:`vim_snippets#Filename('$1', 'ClassName')`}<$2>::~$1 () 
	{
		${0:${VISUAL}}
	}

##
## Class with copy, move constructors, operators
# class
snippet tcle1
	template <class ${4:T}>
	class ${1:`vim_snippets#Filename('$1', 'name')`}
	{
	public:
		$1(${2});
	  $1 ( const $1<$4>& copy );
	  $1<$4>& operator=( const $1<$4>& copy );
	  $1 ( $1<$4>&& move );
	  $1<$4>& operator=( $1<$4>&& move );
		virtual ~$1 ();

	protected:
		${3};
	};

##
## Class with copy, move constructors, operators
# class
snippet dtcle1
	/** @class $1
	 *  @brief ${3:Brief class description}
	 *
	 *  ${4:Detailed description}
	**/
	template <class ${5:T}>
	class ${1:`vim_snippets#Filename('$1', 'name')`}
	{
	public:
	  /**
	   * @brief Create $1
	  **/
		$1(${2});
	  
	  /**
	   * @brief Copy $1 object.
	  **/
	  $1 ( const $1<$5>& copy );
	  
	  /**
	   * @brief Copy operator for $1 object.
	  **/
	  $1<$5>& operator=( const $1<$5>& copy );
	  
	  /**
	   * @brief Move $1 object.
	  **/
	  $1 ( $1<$5>&& move );
	  
	  /**
	   * @brief Move operator for $1 object.
	  **/
	  $1<$5>& operator=( $1<$5>&& move );
	  
	  /**
	   * @brief Destroy $1
	  **/
		virtual ~$1();

	protected:
		${7}; /**< ${6:Member description} **/
	};


# member function implementation
snippet mfun
	${4:void} 
	${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction} ( ${3} ) 
	{
		${0}
	}

snippet mfun0 "create member func with 0 args"
	${3:void} 
	${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction} () 
	{
		${0}
	}

snippet tmfun1.0 "create member func with 0 args"
	template <class ${4:T}>
	${3:void} 
	${1:`vim_snippets#Filename('$1', 'ClassName')`}<$4>::${2:memberFunction} () ${5} 
	{
		${0}
	}
snippet mcon0 "create constructor with 0 arg"
	${1:`vim_snippets#Filename('$1', 'ClassName')`}::$1 () 
	{
		${0}
	}

snippet tmcon1.0 "create constructor for template class with 0 arg"
	template <class ${2:T}>
	${1:`vim_snippets#Filename('$1', 'ClassName')`}<$2>::$1 () 
	{
		${0}
	}

snippet tmcon2.0 "create constructor for template class with 0 arg"
	template <class ${2:T}, class ${3:A}>
	${1:`vim_snippets#Filename('$1', 'ClassName')`}<$2, $3>::$1 () 
	{
		${0}
	}

snippet dcond0 "define constructor with doxygen"
	/** @brief ${1:Brief function description here}
	 *
	 *  ${2:Detailed description of the function}
	**/
	${3:`vim_snippets#Filename('$3', 'ClassName')`} (); 

	${0}

snippet dcond1 "define constructor with doxygen"
	/** @brief ${1:Brief function description here}
	 *
	 *  ${2:Detailed description of the function}
	 *
	 * @param $3 ${5:Parameter description}
	**/
	${6:`vim_snippets#Filename('$1', 'ClassName')`} ( ${4:Type} ${3:Parameter} ); 

	${0}

snippet dcond2 "define constructor with doxygen"
	/** @brief ${1:Brief function description here}
	 *
	 *  ${2:Detailed description of the function}
	 *
	 * @param $3 ${5:Parameter description}
	 * @param $6 ${8:Parameter description}
	**/
	${9:`vim_snippets#Filename('$1', 'ClassName')`} ( ${4:Type} ${3:Parameter}, ${7:Type} ${6:Parameter} ); 

	${0}

snippet dcond3 "define constructor with doxygen"
	/** @brief ${1:Brief function description here}
	 *
	 *  ${2:Detailed description of the function}
	 *
	 * @param $3 ${5:Parameter description}
	 * @param $6 ${8:Parameter description}
	 * @param $9 ${11:Parameter description}
	**/
	${12:`vim_snippets#Filename('$1', 'ClassName')`} ( ${4:Type} ${3:Parameter}, ${7:Type} ${6:Parameter}, ${10:Type} ${9:Parameter} ); 
	
	${0}

snippet dcond4 "define constructor with doxygen"
	/** @brief ${1:Brief function description here}
	 *
	 *  ${2:Detailed description of the function}
	 *
	 * @param $3 ${5:Parameter description}
	 * @param $6 ${8:Parameter description}
	 * @param $9 ${11:Parameter description}
	 * @param $12 ${14:Parameter description}
	**/
	${15:`vim_snippets#Filename('$1', 'ClassName')`} ( ${4:Type} ${3:Parameter}, ${7:Type} ${6:Parameter}, ${10:Type} ${9:Parameter}, ${13:Type} ${12:Parameter} ); 
	
	${0}

snippet mcon1 "create constructor with 1 arg"
	${1:`vim_snippets#Filename('$1', 'ClassName')`}::$1 ( ${2:Type} ${3:Parameter} ) 
	{
		${0}
	}

snippet tmcon1.1 "create constructor with 1 args."
	template <class ${4:T}>
	${1:`vim_snippets#Filename('$1', 'ClassName')`}<$4>::$1 ( ${2:Type} ${3:Parameter} ) 
	{
		${0}
	}

snippet tmcon2.1 "create constructor with 1 args."
	template <class ${4:T}, class ${5:A}>
	${1:`vim_snippets#Filename('$1', 'ClassName')`}<$4, $5>::$1 ( ${2:Type} ${3:Parameter} ) 
	{
		${0}
	}
snippet mfun1 "create member func with 1 arg"
	${5:void} 
	${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction} ( ${3:Type} ${4:Parameter} ) 
	{
		${0}
	}

snippet tmfun1.1 "create member func with 1 arg"
	template <class ${6:T}>
	${5:void} 
	${1:`vim_snippets#Filename('$1', 'ClassName')`}<$6>::${2:memberFunction} ( ${3:Type} ${4:Parameter} ) ${7} 
	{
		${0}
	}

snippet tmfun1.2 "create member func with 2 args"
	template <class ${8:T}>
	${7:void} 
	${1:`vim_snippets#Filename('$1', 'ClassName')`}<$8>::${2:memberFunction} ( ${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter} ) ${9} 
	{
		${0}
	}

snippet mcon2 "create member constructor with 2 args."
	${1:`vim_snippets#Filename('$1', 'ClassName')`}::$1 ( ${2:Type} ${3:Parameter}, ${4:Type} ${5:Parameter} ) 
	{
		${0}
	}

snippet tmcon1.2 "create member template constructor with 2 args."
	template <class ${6:T}>
	${1:`vim_snippets#Filename('$1', 'ClassName')`}<$6>::$1 ( ${2:Type} ${3:Parameter}, ${4:Type} ${5:Parameter} ) 
	{
		${0}
	}

snippet tmcon2.2 "create member template constructor with 2 args."
	template <class ${6:T}, class ${7:A}>
	${1:`vim_snippets#Filename('$1', 'ClassName')`}<$6, $7>::$1 ( ${2:Type} ${3:Parameter}, ${4:Type} ${5:Parameter} ) 
	{
		${0}
	}

snippet tmcon1.3 "create member template constructor with 3 args."
	template <class ${8:T}, class ${9:A}>
	${1:`vim_snippets#Filename('$1', 'ClassName')`}<$8, $9>::$1 ( ${2:Type} ${3:Parameter}, ${4:Type} ${5:Parameter}, ${6:Type} ${7:Parameter} ) 
	{
		${0}
	}

# member function implementation without parameters
snippet dmfun0
	/** @brief ${4:Brief function description here}
	 *
	 *  ${5:Detailed description}
	 *
	 * @return ${6:Return parameter description}
	**/
	${3:void} 
	${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction} () 
	{
		${0}
	}

# member function implementation with one parameter
snippet dmfun1
	/** @brief ${6:Brief function description here}
	 *
	 *  ${7:Detailed description}
	 *
	 * @param $4 ${8:Parameter description}
	 * @return ${9:Return parameter description}
	**/
	${5:void} 
	${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction} ( ${3:Type} ${4:Parameter} ) 
	{
		${0}
	}

# member function implementation with two parameter
snippet dmfun2
	/** @brief ${8:Brief function description here}
	 *
	 *  ${9:Detailed description}
	 *
	 * @param $4 ${10:Parameter description}
	 * @param $6 ${11:Parameter description}
	 * @return ${12:Return parameter description}
	**/
	${7:void} 
	${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction} ( ${3:Type} ${4:Parameter}, ${5:Type} ${6:Parameter} ) 
	{
		${0}
	}

# define namespace
snippet dns "define namespace"
	using namespace ${1:std};
	${0}

# namespace
snippet ns
	namespace ${1:`vim_snippets#Filename('', 'my')`} 
	{
		${0}
	} /* namespace $1 */

##
## Input/Output
# std::cout
snippet cout
	std::cout << ${1} << std::endl;

snippet cerr
	std::cerr << ${1} << std::endl;

# std::cin
snippet cin
	std::cin >> ${1};

##
## Casts
# static
snippet sca
	static_cast <${1:unsigned}> ( ${2:expr} )${3}

# dynamic
snippet dca
	dynamic_cast <${1:unsigned}> ( ${2:expr} )${3}

# reinterpret
snippet rca
	reinterpret_cast <${1:unsigned}> ( ${2:expr} )${3}

# const
snippet cca
	const_cast <${1:unsigned}> ( ${2:expr} )${3}

## Iteration
# for i
snippet fori
	for ( int ${2:i} = 0; $2 < ${1:count}; ${3:++}$2 ) {
		${4}
	}

# for unsigned int
snippet foru
	for ( uint ${2:i} = 0; $2 < ${1:count}; ${3:++}$2 ) {
		${4}
	}

# foreach
snippet fore
	for ( ${1:auto} ${2:i} : ${3:container} ) {
		${4}
	}

# iterator
snippet iter
	for ( ${1:std::vector}<${2:type}>::${3:const_iterator} ${4:i} = ${5:container}.begin(); $4 != $5.end(); ++$4 ) {
		${6}
	}

# auto iterator
snippet itera
	for ( auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1 ) {
		${3:std::cout << *$1 << std::endl;}
	}

##
## Lambdas
# lamda (one line)
snippet ld
	[${1}](${2}){${3}};

# lambda (multi-line)
snippet lld
	[${1}](${2}){
		${3}
	};

# snippets exception
snippet try
	try {
		
	}
	catch ( ${1} ) {
		
	}

snippet ct "catch"
	catch ( ${1} ) {
		
	}

# member function implementation
snippet gtff
	TEST_F ( ${1:`vim_snippets#Filename('$1', 'ClassName')`}, ${2:testFunction} ) 
	{
		${0}
	}

snippet gtfa "google test assert"
	${1:ASSERT_TRUE} ( ${2} );
